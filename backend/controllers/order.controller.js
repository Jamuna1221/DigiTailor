import Order from '../models/order.model.js'
import { sendOutForDeliveryEmail } from '../services/email.service.js'
import { allocateTailorToOrder } from '../services/tailorAllocation.js'

// Create new order with automatic tailor allocation
export const createOrder = async (req, res) => {
  try {
    console.log('📋 Creating new order with tailor allocation...')
    console.log('📤 Received data:', req.body)
    
    const {
      customer,
      items,
      subtotal,
      tax = 0,
      deliveryCharges = 50,
      total,
      paymentMethod = 'cash_on_delivery',
      customerNotes = '',
      shippingInfo
    } = req.body

    // Validation
    if (!customer || !items || items.length === 0 || !total) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: customer, items, total'
      })
    }

    // **SMART TAILOR ALLOCATION**
    const assignedTailorId = await allocateTailorToOrder(items)
    
    // Calculate estimated delivery (7 days from now)
    const estimatedDelivery = new Date()
    estimatedDelivery.setDate(estimatedDelivery.getDate() + 7)

    // ✅ TRANSFORM DATA TO MATCH ORDER MODEL SCHEMA
    const orderData = {
      // orderId will be auto-generated by pre-save hook
      userId: customer, // ✅ Transform customer -> userId
      items: items.map(item => ({
        productId: item.productId,
        name: item.name,
        price: item.price,
        quantity: item.quantity,
        category: item.category,
        image: item.image,
        customizations: item.customizations || {}
      })),
      shippingInfo: shippingInfo ? {
        fullName: shippingInfo.fullName,
        email: shippingInfo.email,
        phone: shippingInfo.phone,
        address: {
          street: shippingInfo.address?.street || shippingInfo.street,
          city: shippingInfo.address?.city || shippingInfo.city,
          state: shippingInfo.address?.state || shippingInfo.state,
          zipCode: shippingInfo.address?.zipCode || shippingInfo.zipCode
        },
        specialInstructions: shippingInfo.specialInstructions || customerNotes
      } : {
        // Fallback if no shippingInfo provided
        fullName: 'Not provided',
        email: 'not@provided.com',
        phone: '0000000000',
        address: {
          street: 'Not provided',
          city: 'Not provided',
          state: 'Not provided',
          zipCode: '000000'
        }
      },
      pricing: { // ✅ Nest in pricing object as model expects
        subtotal: Number(subtotal),
        delivery: Number(deliveryCharges),
        tax: Number(tax),
        total: Number(total)
      },
      payment: {
        method: paymentMethod === 'cash_on_delivery' ? 'cod' : paymentMethod,
        status: 'pending'
      },
      status: assignedTailorId ? 'assigned' : 'placed', // ✅ Valid enum values
      assignedTailor: assignedTailorId,
      allocationTimestamp: assignedTailorId ? new Date() : null,
      estimatedDelivery
    }

    console.log('💾 Transformed data for Order model:', JSON.stringify(orderData, null, 2))

    const newOrder = new Order(orderData)
    const savedOrder = await newOrder.save()
    
    if (assignedTailorId) {
      console.log('✅ Order created and assigned to tailor')
    } else {
      console.log('⚠️ Order created but no tailor available')
    }

    // **USER RESPONSE - NO TAILOR INFO**
    res.status(201).json({
      success: true,
      message: 'Order placed successfully!',
      data: {
        orderNumber: savedOrder.orderNumber || savedOrder.orderId,
        orderId: savedOrder._id,
        estimatedDelivery: savedOrder.estimatedDelivery,
        status: savedOrder.status
        // NO assignedTailor info for customer
      }
    })

  } catch (error) {
    console.error('❌ Error creating order:', error)
    res.status(500).json({
      success: false,
      message: 'Failed to place order. Please try again.',
      error: error.message
    })
  }
}

// **ADMIN - Get all orders with tailor details**
export const getAllOrdersForAdmin = async (req, res) => {
  try {
    const { status, limit } = req.query
    let filter = {}
    
    if (status && status !== 'all') {
      filter.status = status
    }
    
    let query = Order.find(filter)
      .populate('assignedTailor', 'firstName lastName email phone specialties experience') // Include tailor details
      .populate('userId', 'firstName lastName email')
      .sort({ createdAt: -1 })
    
    if (limit) {
      query = query.limit(parseInt(limit))
    }
    
    const orders = await query
    
    res.status(200).json({
      success: true,
      data: orders,
      count: orders.length
    })
    
  } catch (error) {
    console.error('❌ Error fetching orders for admin:', error)
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders'
    })
  }
}

// **TAILOR - Get orders assigned to specific tailor**
export const getOrdersForTailor = async (req, res) => {
  try {
    const { tailorId } = req.params
    const { status } = req.query
    
    let filter = { assignedTailor: tailorId }
    
    if (status && status !== 'all') {
      filter.status = status
    }
    
    const orders = await Order.find(filter)
      .populate('userId', 'firstName lastName')
      .sort({ createdAt: -1 })
    
    res.status(200).json({
      success: true,
      data: orders,
      count: orders.length
    })
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching tailor orders'
    })
  }
}

// **USER - Get user's orders (NO tailor information)**
export const getOrdersForUser = async (req, res) => {
  try {
    const { userId } = req.params
    
    const orders = await Order.find({ userId: userId })
      .select('-assignedTailor -tailorNotes -allocationTimestamp -adminNotes') // Hide tailor info
      .sort({ createdAt: -1 })
    
    res.status(200).json({
      success: true,
      data: orders,
      count: orders.length
    })
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching user orders'
    })
  }
}

// **TAILOR - Update order status and notes**
export const updateOrderByTailor = async (req, res) => {
  try {
    const { orderId } = req.params
    const { status, tailorNotes } = req.body
    
    const updateData = {}
    if (status) updateData.status = status
    if (tailorNotes) updateData.tailorNotes = tailorNotes
    
    const updatedOrder = await Order.findByIdAndUpdate(
      orderId,
      updateData,
      { new: true }
    ).populate('userId', 'email firstName lastName')
    

if (!updatedOrder) {
  return res.status(404).json({ success: false, message: 'Order not found' })
}

// ✅ SEND EMAIL IF STATUS IS OUT FOR DELIVERY
if (updatedOrder.status === 'shipped'||updatedOrder.status === 'shipped') {
  await sendOutForDeliveryEmail(updatedOrder.userId.email, updatedOrder)
}
    if (!updatedOrder) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      })
    }
    
    res.status(200).json({
      success: true,
      message: 'Order updated successfully',
      data: updatedOrder
    })
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error updating order'
    })
  }
}

// Get single order details
export const getOrderDetails = async (req, res) => {
  try {
    const { orderId } = req.params
    const userId = req.user.id // From auth middleware
    
    const order = await Order.findOne({ 
      _id: orderId,
      userId: userId // Ensure user can only see their own orders
    }).populate('assignedTailor', 'firstName lastName email phone')
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      })
    }
    
    res.json({
      success: true,
      data: order
    })
  } catch (error) {
    console.error('Error fetching order details:', error)
    res.status(500).json({
      success: false,
      message: 'Error fetching order details',
      error: error.message
    })
  }
}

// Add review to order
export const addReview = async (req, res) => {
  try {
    const { orderId } = req.params
    const { rating, review } = req.body
    const userId = req.user.id
    
    // Validate input
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({
        success: false,
        message: 'Rating must be between 1 and 5'
      })
    }
    
    const order = await Order.findOne({
      _id: orderId,
      userId: userId,
      status: 'delivered' // Only allow reviews for delivered orders
    })
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found or not yet delivered'
      })
    }
    
    // Check if review already exists
    if (order.review && order.review.rating) {
      return res.status(400).json({
        success: false,
        message: 'Review already submitted for this order'
      })
    }
    
    // Add review
    order.review = {
      rating: Number(rating),
      comment: review,
      createdAt: new Date()
    }
    
    await order.save()
    
    res.json({
      success: true,
      message: 'Review added successfully',
      data: order
    })
  } catch (error) {
    console.error('Error adding review:', error)
    res.status(500).json({
      success: false,
      message: 'Error adding review',
      error: error.message
    })
  }
}

// Add alteration request
export const addAlterationRequest = async (req, res) => {
  try {
    const { orderId } = req.params
    const { request } = req.body
    const userId = req.user.id
    
    // Validate input
    if (!request || request.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Alteration request cannot be empty'
      })
    }
    
    const order = await Order.findOne({
      _id: orderId,
      userId: userId,
      status: 'delivered' // Only allow alteration requests for delivered orders
    })
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found or not yet delivered'
      })
    }
    
    // Add alteration request
    order.alterationRequests.push({
      request: request.trim(),
      status: 'pending',
      createdAt: new Date()
    })
    
    await order.save()
    
    res.json({
      success: true,
      message: 'Alteration request submitted successfully',
      data: order
    })
  } catch (error) {
    console.error('Error adding alteration request:', error)
    res.status(500).json({
      success: false,
      message: 'Error adding alteration request',
      error: error.message
    })
  }
}
